<link rel="stylesheet" href="../../css/contentstyle.css">
<div style="width: 95%; 
            color: #fff; 
            font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            text-align: justify;
            padding-top: 25px;
            padding-left: 2.5%">

    <h1>Синглтон, глобальные объекты, взаимодействия между сценами.</h1>
    <p>Синглтон – порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.</p>
    <p>Простыми словами это одиночка, который будет существовать на момент существования нашего приложения в единственном экземпляре, и к которому можно будет обратиться из любой точки приложения.</p>
    <p>У нас есть некоторые проблемы с глобализацией данных. Вы не можете в какой-либо сцене завести глобальную переменную в одной сцене, записать туда значение и из другой сцены её считать. Когда сцена завершается – всё что было в сцене создано или использовано так же завершает работать с закрытием сцены. Именно здесь на помощь приходит синглтон – объект который не будет стираться и перезаписываться между сценами, даёт вам возможность определять глобальные переменные и методы.</p>
    <p>Самый банальный пример – количество жизней игрока. При переходе от сцены к сцене у игрока должно быть одно и то же количество жизней. Если игрок потерял одну жизнь – количество жизней должно измениться в отрицательную сторону, и следующая сцена должна подгрузить изменённое количество жизней.</p>
    <p>Давайте попробуем реализовать механику количества жизней простыми методами для того, чтобы понять работу синглтона. Для того чтобы реализовать синглтон нам необходимо определить на какой основе он будет сделан. Например, это будет скрипт «global.gd». Давайте создадим такой скрипт, и зайдём в настройки проекта выбрав в главном меню пункты «Проект» - «Настройка проекта». В открывшемся окне нас интересует вкладка «Автозагрузка». Для того чтобы определить синглтон мы должны указать путь до него, наименование синглтона которое будет общим для всех сцен, после чего нажать кнопку «Добавить». Для того чтобы выбрать объект нажмите на иконку папки справа от поля ввода «Путь», и выберите необходимый вам объект. При выборе объекта название подставится самостоятельно, однако вы можете его изменить под свои нужды. Например, задать ему имя буквами в верхнем регистре (заглавными), чтобы выделить объект из вашей общей концепции кодирования. В дальнейшем мы к нему будем обращаться по его имени.</p>
    <p>Нажимаем кнопку добавить – объект задан. Убедитесь, что у него активен пункт «синглтон».</p>
    <div class="imagediv"><img src="imgs/activateSingletone.png"></div>
    <p>Давайте в скрипт «global.gd» добавим какое-нибудь действие, чтобы убедиться что он автоматически загружается и работоспособен. Например:</p>
    <pre><code class="code"><hr>func _ready():
    print("loaded")<hr></code></pre>
    <p>Теперь при запуске тестирования проекта мы увидим в консоли движка надпись «loaded» – наш синглтон работает.
        Давайте функции _ready() дадим другое название, например hello().
    </p>
    <pre><code class="code"><hr>func hello():
    print("loaded")<hr></code></pre>
    <p>Ну а теперь из любого скрипта в сцене обратимся к нему. Можем обратиться так же из нашего спрайта.</p>
    <pre><code class="code"><hr>Global.hello()<hr></code></pre>
    <p>Мы увидим что надпись вывелась. То есть, нам нет необходимости создавать объект касса через new() или instance() – он создаётся при загрузке игры, уже готов к работе и к нему можно обращаться из любой сцены, любого места.</p>
    <p>Давайте сделаем нашу манипуляцию жизнями и переходы между сценами чтобы пронаблюдать, как наше количество жизней переносится между сценами. Для этого мы в нашем скрипте синглтона проинициализируем переменную lifes.</p>
    <pre><code class="code"><hr>var lifes = 3<hr></code></pre>
    <p>Пусть по умолчанию будет 3 жизни. Спрайт, который у нас висит на сцене, уберём из дочерних кнопке элементов, перетащив его на Node2D. Сделаем так, чтобы он убегал не просто так – он должен пытаться спастись. Для этого в его функцию перемещения добавим небольшую обработку. Мы должны высвободить объект если количество жизней закончилось, при этом сами жизни должны отниматься при клике. Должно получиться что-то вроде этого:</p>
    <div class="imagediv"><img src="imgs/livecontrol.png"></div>
    <p>За высвобождение отвечает оператор queue_free() – он убирает объект И ЕГО ДОЧЕРНИЕ ЭЛЕМЕНТЫ со сцены и высвобождает его из памяти.</p>
    <p>Для того чтобы у нас при переходе на сцену, если мы уничтожили объект, он восстановился, мы должны восстановить ему количество жизней. Для этого в Node2D повесим скрипт, который бы обновлял количество жизней если их количество меньше нуля.</p>
    <pre><code class="code"><hr>func _ready():
    if Global.lifes < 0:
        Global.lifes = 3<hr></code></pre>
    <p>Нам остаётся добавить счётчик жизней, чтобы он показывал нам количество жизней.
        Для этого нам нужен узел control, в котором дочерними элементами мы поставим обозначение нашего спрайтика новым спрайтом, и обозначение количества жизней узлом Label.
    </p>
    <div class="imagediv"><img src="imgs/liveviewer.png"></div>
    <p>Теперь на Label повесим скрипт, который будет проверять количество жизней и отображать их:</p>
    <pre><code class="code"><hr>func _process(delta):
    text = str(Global.lifes)<hr></code></pre>
    <p>Теперь, когда мы кликаем по спрайту, его жизни уменьшаются, и это отображается на экране, и по окончанию жизней спрайт высвобождается.</p>
    <p>Остаётся самая мелочь – мы должны видеть, как наши жизни сохраняют своё значение при изменении сцен. Если вы ещё не запустили проект – запустите, чтобы сцена сохранилась, а также проверить проект.</p>
    <p>Всё что мы сделаем сейчас – скопируем нашё сцену, внесём некоторые изменения во вторую сцену, и добавим их переключение по кнопке.</p>
    <p>Скопировать сцену просто – в файловой системе проекта кликаем правой кнопкой мыши на нашу сцену, и выбираем пункт дублировать, после чего в открывшемся окне изменяем имя под свой вкус и сохраняем. Двойным кликом открываем нашу вторую сцену, и добавим туда что-нибудь визуальное, чтобы, когда мы будем переключаться между сценами – нам по внешнему виду сцены было понятно, что сцена изменилась.</p>
    <p>Ну и теперь в каждой сцене в код кнопки добавим get_tree().change_scene() где в качестве параметра передатим путь до другой сцены, перетащив её из файловой системы проекта. Вот пример для одной сцены:</p>
    <pre><code class="code"><hr>func _on_Button_button_down():
        get_tree().change_scene("res://Node2D.tscn")<hr></code></pre>
    <p>В другой сцене мы открепляем скрипт из кнопки, и скопируем его – так нам будет проще всего сделать. В скопированном мы уже меняем путь сцены, и привязываем скопированный скрипт к кнопке.</p>
    <p>Дело в том, что при копировании у нас скопировалось описание сцены – информация о расположении файлов и прикреплении скриптов, но не скопировались элементы. Это значит, что к двум разным кнопкам двух разных сцен у нас привязан один и тот же скрипт – именно поэтому в одной из сцен мы должны отвязать скрипт, и прикрепить изменённую копию. На рисунке далее Вы так же можете увидеть, что это два разных скрипта – Button и ButtonOrig.</p>
    <div class="imagediv"><img src="imgs/tweens.png"></div>
    <p>Запускайте сцену, и теперь кликайте – Вы видите, что наш персонаж пытается убежать, и может умереть если у него сбежать не получилось. </p>
</div>
<script src="../../scripts/codehighlighter.js"></script>