<link rel="stylesheet" href="../../css/contentstyle.css">
<div style="width: 95%; 
            color: #fff; 
            font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            text-align: justify;
            padding-top: 25px;
            padding-left: 2.5%">

    <h1>Музыкальный плеер</h1>
    <p>Теперь пойдём немного дальше – реализуем аудиоплеер. Зачастую мы пользуемся проектными ресурсами – данными, которые запечатаны непосредственно в проекте. Но в данном проекте мы будем открывать и воспроизводить аудиофайлы непосредственно с диска.</p>
    <p>Для начала выбираем корневым узлом «2D сцена», и выставим настройки отображения нашего приложения, как мы это делали с калькулятором. Так же в настройках проекта, в графе «Дисплей», пункт «Окно» - выставляем ширину – 640, высоту – 420, убираем галочку изменяемого размера. Закрываем окно, и добавим первостепенные компоненты:</p>
    <ul>
        <li>Диалоговое окно открытия файла (узел «FileDialog»)</li>
        <li>Воспроизводящий аудиопоток (узел «AudioStreamPlayer»)</li>
        <li>Кнопки для открытия файла, воспроизведения и остановки (узел «Button»)</li>
    </ul>
    <img src="imgs/musicplayer.png" align="right">
    <p>Для диалогового окна необходимо поменять несколько пунктов в инспекторе. В дереве сцены выделяем узел «FileDialog», и в окне инспектора ставим следующие значения:</p>
    <ul>
        <li>Mode – Open File</li>
        <li>Access – File System</li>
    </ul>
    <p>Там же находим параметр «Filters», и кликаем непосредственно на заданный аргумент «PoolStringArray». В открывшемся вложении увеличиваем размер до одного, и в появившемся поле вписываем формат файлов *.mp3 (звёздочка указывает на то, что перед указанием формата файл будет обозначен неизвестным количеством неизвестных символов).</p>
    <p>По умолчанию узел «FileDialog» не виден, и для его отображения необходимо вручную заставить его появиться. Но для настройки мы можем включить его отображение в редакторе нажав на значок глаза рядом с узлом. Настройте ширину и высоту таким образом, чтобы в диалоговом окне было пространство для отображения списка файлов. Теперь создаём скрипт для узла Node2D, и присоединяем сигналы кнопок («pressed») к данному узлу.</p>
    <p>Теперь по нажатию кнопки открытия файла необходимо показать диалоговое окно.</p>
    <pre><code class="code"><hr>func _on_open_pressed():
    $FileDialog.popup()<hr></code></pre>
    <p>Сохраните сцену, проверьте работу кнопки.</p>
    <p>Окно появляется, но при выборе файла ничего не происходит. Дело в том, что при выборе файла узел «FileDialog» скрывается, и отправляет сигнал «file_selected», для которого нет обработчика. Также, как с кнопками ранее, необходимо присоединить данный сигнал этого узла к скрипту через док «Узел», и далее описать в ново созданной функции обработку. Для начала нам предстоит открыть файл по пути, указанному узлом «FileDialog», и получить сырые данные файла.</p>
    <pre><code class="code"><hr>func _on_file_dialog_file_selected(path):
    var file = FileAccess.open(path, FileAccess.READ)
    var bytes = file.get_buffer(file.get_length())<hr></code></pre>
    <p>Далее необходимо создать необходимый объект аудиофайла, и считать данные файла в этот объект, после чего закрыть файл (закрывать файл необходимо после окончания работы с файлом для того, чтобы он был доступен для всех остальных программ на компьютере). И в самом конце функции необходимо указать узлу AudioStreamPlayer тот объект, в который мы записали данные с файла. Давайте сделаем это для файлов с расширением mp3</p>
    <pre><code class="code"><hr>sound = AudioStreamMP3.new()
    sound.data = bytes
    file.close()
    $AudioStreamPlayer.stream = sound<hr></code></pre>
    <p>Так как переменной sound у нас нет – заведите её глобально, указав её в коде в качестве пустышки (var sound) перед всеми функциями скрипта. Теперь присоединяем сигналы кнопок «play» и «stop» и опишем воспроизведение и остановку звука по нажатию кнопок:</p>
    <pre><code class="code"><hr>func _on_play_pressed():
    $AudioStreamPlayer.play()
func _on_stop_pressed():
    $AudioStreamPlayer.stop()<hr></code></pre>
    <p>Запускаем приложение для теста, открываем нашим плеером mp3 файл, воспроизводим. Выглядит это пока слишком скучно. Добавьте узлы «HSlider» (он будет отвечать за громкость звука), и «Label» (будет отображать время воспроизведения).</p>
    <p>Назовите узел «HSlider» как «Volume», и выставьте в его свойствах значение Min Value на -60, а Max Value на 0.</p>
    <p>Если посмотреть на сигналы «Volume», то можно заметить, что у него нет сигнала на отслеживание текущего значения. Вместо этого воспользуемся сигналами «drag_started()», и «drag_ended()». Для удобства создадим скрипт на слайдере, и присоединим эти сигналы к нему. Нам необходимо сделать одну переменную, которая бы указывала на необходимость изменения громкости звука – «dragged». Изменение громкости звука мы опишем во встроенной функции _process(delta), и зависеть оно будет от значения переменной dragged, которое мы будем изменять в присоединённых сигналах. Изменять будем громкость узла отвечающего за воспроизведение звука.</p>
    <pre><code class="code"><hr>extends HSlider

var dragged = false

func _process(delta):
    if dragged:
        $"../AudioStreamPlayer".volume_db = value

func _on_Volume_drag_started():
    dragged = true

func _on_Volume_drag_ended(value_changed):
    dragged = false<hr></code></pre>
    <p>Теперь поработаем с добавленным лейблом. Расположите его в комфортном месте, и прикрепите к нему скрипт, задав ему следующее содержимое:</p>
    <pre style="width: 100%"><code class="code"><hr>extends Label
var PlayerTime
func _process(delta):
    PlayerTime = int($"../AudioStreamPlayer".get_playback_position())
    var hours = "%02d" % [PlayerTime / 3600]
    var minutes = "%02d" % [PlayerTime / 60]
    var seconds = "%02d" % [PlayerTime % 60]
    self.text = hours + ":" + minutes + ":" + seconds.<hr></code></pre>
    <p>Таким образом, обращаясь к AudioStreamPlayer мы опрашиваем его время с момента начала воспроизведения, и отображаем время в лейбле в формате «часы: минуты: секунды».</p>
    <p>Проверяем работу импровизированных ползунка громкости и таймера. Если всё работает, то идём дальше – добавим визуализацию, чтобы пользователю было не скучно. Добавьте на сцену узел «Control», и прикрепите к нему скрипт. Далее откройте аудиомикшер, и добавьте на мастерканал эффект «SpectrumAnalyzer», как показано на рисунке.</p>
    <div class="imagediv"><img src="imgs/mixer.png"></div>
    <img src="imgs/spectroanalyzer.png" align="right">
    <p>Теперь в скрипте узла «Control» обратимся к каналу «Master» (так как он единственный, то он является единственным элементом списка каналов, и в списке каналов индексируется как нулевой. Точно так же и спектроанализатор, являющийся единственным эффектом данного канала, является нулевым в списке. Помним, что компьютер считает с нуля, и для него 0 яблок – тоже некоторое количество яблок).</p>
    <p>Спектроанализатор нам зачастую знаком в качестве эквалайзера – звук обладает некоторой частотой, и спектроанализатор, разделяя эти частоты в музыке, предоставляет нам информацию об интенсивности частот определённого диапазона в виде столбчатой диаграммы.</p>
    <p>Открываем скрипт узла «Control», и добавим туда ссылку на наш аудиоэффект:</p>
    <pre><code class="code"><hr>var spectrum: AudioEffectInstance
func _ready():
    # Сперва указываем канал, после номер эффекта
    spectrum = AudioServer.get_bus_effect_instance(0,0)<hr></code></pre>
    <p>Спектроанализатор не умеет самостоятельно разделять частоты, поэтому его необходимо этому научить. Для этого определим в начале скрипта несколько переменных отвечающих за конфигурацию спектров:</p>
    <pre><code class="code"><hr>const VU_CNT = 16.0	# Количество столбиков диаграммы
    const FRQMAX = 12000.0	# Максимальная анализируемая частота
    const w = 500			# Ширина столбиков
    const h = 120			# Высота столбиков
    const MIN_DB = 60		# Минимальная анализируемая частота<hr></code></pre>
    <p>И теперь мы обработаем данные спектроанализатора на основе нашей конфигурации в функции _draw(). Функция _draw() – одна из встроенных функций, и существует для возможности отрисовки некоторых элементов (таких, как геометрические примитивы, к примеру) без необходимости использования узлов. Она не вызывается неявно, поэтому нам будет необходимо вызывать её в _update():</p>
    <pre><code class="code"><hr>func _process(delta):
    update()<hr></code></pre>
    <p>Теперь, когда функция _draw() будет вызвана для отрисовки, нам необходимо её описать. Поэтапно опишем отрисовку диаграммы спектроанализатора:</p>
    <pre><code class="code"><hr>func _draw():
    var colw = w / VU_CNT	# Определяем ширину столбцов
    var prev_hz = 0		# Определяем левую границу частот
    for i in range(1, VU_CNT + 1):  # Описываем каждый столбик диаграммы в цикле
        var hz = i * FRQMAX / VU_CNT	# определяем правую границу диапазона
        # Получаем данные об интенсивности выбранного диапазона частот
        var mag: float = spectrum.get_magnitude_for_frequency_range(prev_hz, hz).length()
        # Получаем линейное усреднённое значение интенсивности
        var energy = clamp((MIN_DB + linear2db(mag)) / MIN_DB, 0, 1)
        # На основании предыдущего вычисления вычисляем высоту столба
        var colh = energy * h
        # Рисуем прямоугольник
        draw_rect(Rect2(colw * i + 20, h - colh+60, colw*0.95, colh * 2), Color.palevioletred)
        prev_hz = hz # Запоминаем границу диапазона для следующих вычислений<hr></code></pre>
    <p>Описания используемых функций в коде можно посмотреть при помощи документации, щёлкнув на какой-либо из операторов с зажатой клавишей «CTRL». Единственное что следует помнить – уровень звука не линейный (не равномерен на графике), и поэтому необходимо делать подобные преобразования для получения линейного значения.</p>
    <p>Всё что нам остаётся – растянуть наш узел Control по ширине и высоте нашего плеера, и наслаждаться визуализацией при проигрывании звука.</p>
    <p><b>Задание:</b>
        <i>добавьте на канал микшера другой эффект (например, реверберацию – эхо, которое мы слышим, когда кричим в колодец), с делайте некоторое средство управления («Slider») для этого эффекта таким образом, чтобы при взаимодействии с ним отчётливо ощущать разницу в звуке, создаваемую данным эффектом.</i>
    </p>
    <a href="projects/02 MusicPlayer.zip" class="project_button">
        <button class="project_button">
            <img src="../../imgs/download.png" style="max-height: 100%">
            Демонстрационный проект
        </button>
    </a>
    <br><br>
</div>
<script src="../../scripts/codehighlighter.js"></script>