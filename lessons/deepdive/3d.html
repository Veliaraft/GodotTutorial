<link rel="stylesheet" href="../../css/contentstyle.css">
<div style="width: 95%; 
            color: #fff; 
            font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            text-align: justify;
            padding-top: 25px;
            padding-left: 2.5%">

    <h1>3D Платформер</h1>
    <p>Для реализации 3D шутера можно воспользоваться уже готовыми компонентами. Одним из таких является, например, "First Person Controller (FPS)", который в Godot Assetlib любезно был предоставлен для общего пользования неким "Linko", за что ему огромное спасибо!
    <div class="imagediv"><img src="imgs/FPSController.png"></div>
    Данный ассет после загрузки не требует установки. После установки в дереве ресурсов появляется некий компонент "Player.tscn", который можно перетащить в сцену. Да, всё понимается правильно - дело в том, что данный компонент является сценой, в которой запечатлён персонаж, которого достаточно перенести в сцену для использования. У него есть свои сигналы кнопок, которые необходимо настроить в настройках проекта. В реализации уже есть два оружия - автомат и пистолет. Они имеют под собой 3D-модели оружия, анимации, и непосредственно свои манеры стрельбы и перезарядки. Данное дополнение уже имеет рейкаст, который способен определять по группе в кого производится выстрел, и если непосредственно выстрелить в пустой статический объект - в стену, то в месте попадания реализовано осыпание осколков. Довольно интересное решение, которое можно загрузить и переработать под себя, но есть одно но... Мы ещё не совсем понимаем как в принципе с этим работать, и что с этим делать... Поэтому займёмся реализацией 3D-контроллера самостоятельно, а именно создадим объект игрока, заставим его научиться ходить, прыгать, крутить головой, и сделаем из этого достаточно простой платформер.</p>
    <p>Для этого создадим новый проект, и сделаем то, чего мы ещё никогда не делали. !!!ВНИМАНИЕ!!!, выбираем 3D сцену. На данном моменте трудно накосячить, но если всё же у Вас получилось - сравните, как движок должен выглядеть на данный момент:
    <div class="imagediv"><img src="imgs/3dviewport.png"></div>
    Опробуйте себя в пространстве, попробуйте с ним поработать. Используйте следующие клавиши для управления.</p>
    <ol>
        <li><b>Левая кнопка мыши</b> - выделение объектов. Зажатие отвечает за прямоугольное выделение объектов.</li>
        <li><b>Правая кнопка мыши</b> - в зажатом положении отвечает за поворот камеры вокруг своей оси. Также, дополнительное нажатие W, A, S или D отвечает за перемещение камеры в пространстве, а Q и E за отпускание и поднятие камеры, соответственно.</li>
        <li><b>Средняя кнопка мыши</b> - в зажатом положении отвечает за поворот с перемещением камеры вокруг некоторой точки.</li>
        <li><b>Средняя кнопка мыши + клавиша Shift</b> - перемещение камеры "крабиком" в пространстве (если кто не знал, то вот вам удивительный факт - крабы не умеют ходить вперёд, они ходят только боком)</li>
        <li><b>Средняя кнопка мыши + клавиша Ctrl</b> - отвечает за приближение и отдаление камеры вьюпорта.</li>
    </ol>
    <p>Вы можете заметить сильное отличие в дереве сцены - теперь корневым узлом у нас является Spatial, а не Node2D. Spatial переводится как "пространственный". То есть, если Node2D отвечает за реализацию плоских объектов - 2D, то Spatial отвечает за реализацию трёхмерных объектов. Небольшое отступление по этому поводу было в конце раздела "Программирование", тема - "Структура проекта, события, сигналы".</p>
    <p>Создадим персонажа. Для этого нам необходимо добавить узел kinematicBody (обычный, НЕ 2D!!!). Твёрдое тело персонажа есть - надо определить для него границы твёрдости. Добавьте ему CollisionShape. Что самое интересное, у нас в игре могут быть изогнутые поверхности и лестницы. Для таких ситуаций остроугольные коллизии могут сказаться багами - игрок не сможет взобраться по лестнице... Вот так вот и завершаются революции, даже не начавшись...</p>
    <div class="imagediv"><img src="imgs/robolution.jpg"></div>
    <p>Поэтому во избежание таких ситуаций была придумана специальная форма - CapsuleShape. Она существует как цилиндр, что позволяет задать размер коллайдера в рост персонажа, и при этом имеет некоторые закругления с краёв, решающие проблемы лестниц. По умолчанию, когда Вы добавите CapsuleShape, он будет повёрнут горизонтально. Но вокруг центра Вы увидите круги и стрелочки, которые отвечают за трансформацию тела в пространстве. Потяните за красный круг зажав и удерживая клавишу Ctrl, тем самым повернув капсулу правильно. Далее отредактируйте размеры капсулы, перетаскивая оранжевые кружки на её границах (они небольшие. Один будет внизу, или вверху в зависимости от того, как Вы повернули капсулу, а второй будет сбоку). Далее, чтобы капсула не была провалена в пол (а она у нас по умолчанию создаётся в полу - в центре координат мира), Вы можете поднять её вверх потянув за зелёную стрелку.</p>
    <div class="imagediv"><img src="imgs/shapeedit.png"></div>
    <p>Помимо этих основных элементов можно ещё увидеть и квадраты, в качестве управляющих элементов для масштаба фигуры. Они могут понадобиться при работе с 3д моделями, но с формами коллизий лучше такими параметрами не баловаться.</p>
    <p>Окей, это тело персонажа, и оно имеет некоторую коллизию. Скучно... Надо lkz Spatial добавить дочерним StaticBody, чтобы с эксперементировать с новосозданным туловищем. Для StaticBody добавьте CollisionShape в форме куба, и также расположите его под персонажем и придайте ему форму побольше, чтобы было по чему ходить. Грустно когда персонаж ходит по маленькому кубику - сделайте кубик большим, пусть ходит по большому. Чтобы мы видели по чему персонаж будет ходить, можно пока-что для одной из сторон кубика расположить спрайт с иконкой Godot - просто добавить </p>
    <div class="imagediv"><img src="imgs/3dWtihSprite.png"></div>
    <p>Ну и так как персонаж - не более чем коллизии, то мы не сможем его увидеть в игре. Для того, чтобы он был виден в игре, ему необходима визуальная форма. Как таковую ыизуальную форму мы ему задавать не будем - Вы попробуете сделать это позже, если будете создавать свою игру и вставлять туда противников. Мы ограничимся визуальной формой платформ, на которых сделаем игру, а пока её нет - для очевидного результата мы сделаем взгляд от первого лица, и реализуем управление персонажем.</p>
    <p>Чтобы сделать взгляд, необходимо добавить камеру персонажу. Не забываем указать камере Current, чтобы она была в качестве основной, расположить её не в самой макушке, а чуть ниже - у человека глаза, всё-таки, не на макушке, и, добавив скрипт персонажу, реализуем повороты.</p>
    <pre><code class="code"><hr>extends KinematicBody

var _mouse_motion = Vector2() # определяем переменную для съёма показаний движения мыши
onready var camera = $Camera # находим камеру

func _ready():
    Input.mouse_mode = Input.MOUSE_MODE_CAPTURED # захватываем мышь для того, чтобы курсор не мешал играть.

func _process(delta):
    # описываем повороты по перемещению мыши.
    _mouse_motion.y = clamp(_mouse_motion.y, -1550, 1550) # clamp() задаёт ограничение по перемещению. Уберите clamp, и Вы увидите, как камера способна просто переворачиваться без таких ограничений.
    transform.basis = Basis(Vector3(0, _mouse_motion.x * -0.001, 0))
    camera.transform.basis = Basis(Vector3(_mouse_motion.y * -0.001, 0, 0))

func _input(event):
    # определяем событие, которое будет снимать данные о перемещении мыши в переменную.
    if event is InputEventMouseMotion:
        if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
            _mouse_motion += event.relative<hr></code></pre>
    <p>Что из этого самое интересное, так это то, что повороты указываются по базису (относительно заданной системы координат объекта). "МАТЕМАТИКА МНЕ НЕ НУЖНА, ОНА МНЕ В ЖИЗНИ НЕ ПРИГОДИТСЯ" - вот, пожалуйста, понятие базиса является частью школьной учебной программы по геометрии. Для описания всех применяемых методов школьного курса математики даже недостаточно, ибо вместе с поворотом по базису повсеместно используется описание поворота тела через углы Эйлера, а далее и вовсе идёт описание поворота через кватернион. Не пытайтесь вникнуть в природу существования данных феноменов без должной подготовки, ибо есть достаточно сильный риск свихнуться, и возненавидеть математику вовсе. Моя рекомендация новичкам на текущий момент - погуглить что это такое, где используется, как это использовать в Godot, и самое главное - для чего, и просто использовать это не углубляясь в формулы и строение. Конкретно в документации Godot, чтобы Вам было легче, дано вот такое описание базиса - "Основой является матрица, содержащая 3 вектора 3 в качестве столбцов: ось X, ось Y и ось Z. Эти векторы могут быть интерпретированы как базисные векторы локальной системы координат, перемещающиеся вместе с объектом."</p>
    <p>Теперь перемещение. Сперва необходимо чтобы персонаж опустился на землю. Для этого используем встроенную гравитацию, и опишем переменную velocity, которая будет отвечать за смещение тела в пространстве, как мы это делали в 2D. Гравитацию мы получим из настроек проекта:</p>
    <pre><code class="code"><hr>onready var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")
var velocity = Vector3()<hr></code></pre>
    <p>Далее мы опишем функцию _physics_process(), в котором будем запрашивать клавиши от игрока.</p>
    <pre><code class="code"><hr>func _physics_process(delta):
    var movement_vec2 = Input.get_vector("move_left", "move_right", "move_forward", "move_back") # получение информации о нажатии клавиш
    var movement = transform.basis.xform(Vector3(movement_vec2.x, 0, movement_vec2.y)) # определяем смещение по координатам
    velocity.y -= gravity * delta # применяем гравитацию
    velocity = move_and_slide(Vector3(movement.x, velocity.y, movement.z), Vector3.UP) # производим смещение (перемещение объекта)
    if is_on_floor() and Input.is_action_pressed("jump"): # реализуем прыжок, если нажата клавиша прыжка, и персонаж находится на земле.
        velocity.y = 5<hr></code></pre>
    <p>У меня он ходил слишком медленно. В таких случаях можно в move_and_slide добавить некоторый множитель скорости. Конкретно - можно умножать значения movement.x и movement.z (так как за смещение у нас отвечает именно movement) на некоторое число. Например, можно умножить на 2, чтобы увеличить скорость в два раза.<br>Также обратите внимание на то, что в захвате клавиш у нас используется пять действий - "move_left", "move_right", "move_forward", "move_back", и "jump". Этих клавиш по умолчанию нет - их необходимо добавить в проект в настройках проекта, вкладка "Список действий". Запустите, проверьте работу, и всё ли Вы сделали правильно.</p>
    <p>Мы уже почти всё сделали! Персонаж ходит по некоторой плоскости, управление работает, но в игре нет игры. Так как это платформер - давайте дадим игроку некоторую цель. Например, добраться от точки до точки по платформам. Для этого прежде всего нам нужны платформы. Требуемые 3д-модели я уже сделал, и приложил в папке с проектом. Пользуйтесь на здоровье! Сделал я это лишь для того, чтобы показать одну из важных частей при работе с моделями - создание твёрдого тела на основе модели. Для этого нам необходимо импортировать модель в редактор - перетяните файл с моделью в редактор. Мы работаем с форматом glb - это сравнительно новый формат, но он прекрасно поддерживается Godot. Импортируется он как сцена, а поэтому нам будет необходимо после импорта зайти в него двойным кликом мыши, и во всплывающем окне выбрать "новая унаследованная сцена". При редактировании модели некоторые изменения могут не сохраниться, поэтому нам необходимо создавать из неё новую сцену, и сохранять её.</p>
    <p>В сцене 3д модели можно обнаружить узел Spatial в качестве основного, и дочерним к нему, как правило, будет узел типа MeshInstance. Дочерних узлов может быть множество - в зависимости от того, сколько объектов содержит модель. В нашем случае необходимо выделить основную платформу, и перейти в меню "Mesh" -> "Создать вогнутое статичное тело"</p>
    <div class="imagediv"><img src="imgs/staticfrommesh.png"></div>
    <p>Таким образом нам нет необходимости строить коллайдер определённой формы для данного объекта - статическое тело содержащее требуемую коллизию будет создано автоматически. Сохраните сцену, и вернитесь к сцене с персонажем.</p>
    <p>В сцене с персонажем теперь можно убрать наш статический кубик - он нам больше не нужен. Вместо него размещаем нашу новосозданную сцену с платформой, и радуемся - теперь персонаж ходит по некоторому красочному объекту. На что ещё хотелось бы обратить внимание - на модели есть некоторый выступ, и так как он является частью меша, для которого мы создали коллизию, он влияет на перемещение персонажа - персонаж поднимается по нему в отличии от стрелочки, для которой мы коллизию не добавляли.</p>
    <p>Я создал несколько таких платформ, и повернул их таким образом, чтобы стрелочки показывали куда прыгать - указывали путь. Но я разместил их на разной высоте, и добраться до некоторых не так уж и просто. Поэтому мы создадим некоторые модификаторы перемещения, которые будут давать второй прыжок в воздухе персонажу, либо увеличивать скорость его перемещения. Но мы предоставим игроку их столько, сколько будет необходимо чтобы пройти уровень, и каждый из них будет необходимо подобрать на карте.</p>
    <p></p>
    <p></p>
    <p></p>
    <img src="" align="right">
    <ol>
        <li></li>
    </ol>
    <div class="imagediv"><img src=""></div>
    <pre><code class="code"><hr><hr></code></pre>
    <a href="projects/3D Platformer.zip" class="project_button">
        <button class="project_button">
            <img src="../../imgs/download.png" style="max-height: 100%">
            Демонстрационный проект
        </button>
    </a>
<br><br>
</div>
<script src="../../scripts/codehighlighter.js"></script>