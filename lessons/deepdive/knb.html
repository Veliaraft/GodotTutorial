<link rel="stylesheet" href="../../css/contentstyle.css">
<div style="width: 95%; 
            color: #fff; 
            font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            text-align: justify;
            padding-top: 25px;
            padding-left: 2.5%">

    <h1>"Камень, ножницы, бумага"</h1>
    <h2 style="color: red">!!! Предупреждение !!! Множество материалов, приведённых в данной части курса, ссылаются на первую часть курса - "Программирование". Настоятельно рекомендуется пройти первую часть курса! Не пытайтесь свернуть горы без знания базы программирования, ибо в таком случае у Вас выше вероятность свернуть свою деятельность, и желание разрабатывать игры!!!</h2>
    <p>Давно известная всем игра, которую, в качестве проекта для тренировки, выполняют новички в виде консольного приложения. Мы же сделаем его в графическом виде.</p>
    <p>Что нам понадобится для этого:</p>
    <ol>
        <li>Карта компьютера, чтобы пользователь мог видеть результат игры наглядно, и сравнить со своим выбором;</li>
        <li>Карты пользователя, чтобы пользователь из трёх карт мог выбрать один вариант;</li>
        <li>Подсчёт очков, чтобы видеть результаты сыгранных игр;</li>
        <li>Какое-либо уведомление о проигрыше, либо выигрыше;</li>
        <li>Так как это игра - хотелось бы, чтобы игра вела себя более плавно, с анимациями. Используем AnimationPlayer.</li>
    </ol>
    <p>Необходимые ресурсы для выполнения можно взять в папке демонстрационного проекта.</p>
    <p>Добавим карту компьютера - это обычный спрайт. Нам нужно скрыть карту компьютера, поэтому просто перетянем изображение рубашки карты на рабочее поле. После этого добавим три кнопки для пользователя - это будут карты. А чтобы кнопки выглядели как карты - мы укажем им параметр "Flat", и в качестве текстуры укажем на каждую из кнопок своё изображение карты. Для удобства я назвал каждую карту соответствующим ей символом. В качестве демонстрации результатов сыгранных игр будем использовать обычное текстовое поле - Label. Добавьте два лейбла - один будет отображать очки пользователя, другой очки компьютера. Расставьте удобным для Вас образом. У меня получилось вот так:</p>
    <div class="imagediv"><img src="imgs/cardproperties.png"></div>
    <img src="imgs/knbtree.png" align="right">
    <p>Какую анимацию мы желаем видеть? Я бы хотел, чтобы когда пользователь выбирает карту - карта компьютера разворачивалась, и показывала определённое изображение, которое бы соответствовало логике игры. Для реализации такого эффекта нам не понадобится изменять параметры спрайта в коде - это довольно глупо. Для этого есть уже готовый узел, который автоматизирует анимации - AnimationPlayer. Добавьте данный узел в дерево сцены рядом с другими узлами.</p>
    <p>И остаётся добавить некоторую информацию, которая сообщала бы пользователю, является он победителем, или же проигравшим - ещё один Label, который расположим в середине сцены, в инспекторе укажем "Align" -> "Center", и скроем. Что в нём будет написано - не важно, надпись изменим в коде. Про добавленный таймер на картинке поговорим позже.</p>
    <p>Для написания всей логики игры мы добавим всего лишь один скрипт - я добавил его в Node2D. В этом скрипте мы опишем все взаимодействия, и всю логическую часть, которая непосредственно и является игрой. Так как у нас всего три значения - опишем их в коде в строго определённом порядке. Почему? Объясняю:</p>
    <p>Возьмём первым камень. Он кроется бумагой - бумага на второй позиции, но тупит ножницы - ножницы на третьей позиции. Теперь сместим их на позицию влево - бумага стоит на первом месте. Она режется ножницами, которые находятся теперь на втором месте, кроет камень, который находится теперь на третьем месте. Попробуйте опять сместить список влево. Вы заметили, что у нас всегда, при смещении списка на одну позицию получается так, что второй сильнее первого, но слабее третьего? Этой хитростью мы и воспользуемся!</p>
    <pre><code class="code"><hr>var cards = ["Rock", "Paper", "Scissors"]<hr></code></pre>
    <p>Также хотелось бы отслеживать результат, ведь он может быть как положительным для игрока, так и отрицательным, и нейтральным. В этом мы и используем нашу хитрость с расстановкой карт - мы будем смещать список таким образом, что карта пользователя будет посередине. И, хотелось бы, чтобы компьютер понимал какую карту необходимо показать. Эти данные мы будем сохранять в переменных.</p>
    <pre><code class="code"><hr># Переменная для фиксации результата матча
var game_result = 0
# Переменная, которая будет содержать картинку выбранной компьютером карты
var pc_card_image<hr></code></pre>
    <p>Ну и теперь, после того как мы всё подготовили, соединим нажатие кнопок с некоторой функцией, и опишем такую функцию:</p>
    <pre><code class="code"><hr>func _ready():
    # Здесь надо сделать часть отвечающую за показ очков матчей.

    # Перенаправляем сигналы кнопок с передачей необходимых данных
    $Rock.connect("pressed", self, "card_changed", ["Rock"])
    $Paper.connect("pressed", self, "card_changed", ["Paper"])
    $Scissors.connect("pressed", self, "card_changed", ["Scissors"])

func card_changed(card):
    # Задаём компьютеру случайную карту
    randomize()
    var pc_card = cards[randi() % 3]
    # Изображение карты компьютера задаётся путём подмешивания значения переменной в путь ресурса.
    pc_card_image = load("res://" + pc_card + ".png")
    # Изменяем список таким образом, чтобы карта игрока была посередине
    while cards[1] != card:
        cards.append(cards[0])
        cards.remove(0)
    # Определяем результат битвы. Карта пользователя посередине и равна индексу 1
    # cards[0] - карта слабее карты игрока, cards[2] - сильнее
    if cards.find(pc_card) > 1:
        game_result = -1
        # Здесь надо ещё сделать часть отвечающую за подсчёт очков.
    elif cards.find(pc_card) < 1:
        game_result = 1
        # Здесь надо ещё сделать часть отвечающую за подсчёт очков.
    # Запуск анимации
    $AnimationPlayer.play("open_card")
    <hr></code></pre>
    <p>randomize() делает интересную вещь. Если каждый раз запускать генерацию случайных чисел - при каждом запуске случайные числа будут повторяться, как будто программа генерирует случайные числа по предварительному сценарию из книги. randomize() делает так, чтобы каждый раз при запуске генерации генерировались действительно случайные числа, которые не будут повторять последовательностей генераций. Ну а откуда взялась анимация? Она была создана ещё до написания кода, но указана здесь ради того, чтобы по этому примеру Вы добавили свою анимацию. Для этого в дереве сцены выберите AnimationPlayer, и в нижнем доке у Вас откроется редактор анимаций, в котором необходимо нажать "Анимация" -> "Новый". Назовите анимацию некоторым именем, которое мы и будем указывать в коде как анимацию, которую необходимо запустить.</p>
    <div class="imagediv"><img src="imgs/animationcreating.png"></div>
    <p>После добавления анимации у Вас появится временная шкала, и возможность добавить некоторый анимируемый аргумент:</p>
    <div class="imagediv"><img src="imgs/animationtimeline.png"></div>
    <ol>
        <li>Трек параметра - изменение какого-либо параметра некоторого объекта сцены;</li>
        <li>Трек 3D преобразования - воздействие на параметры трёхмерных объектов;</li>
        <li>Трек вызова метода - можно вызвать определённую функцию некоторого объекта;</li>
        <li>Трек кривой Безье - математически описанная кривая, используемая в компьютерной графике. Представьте, что у Вас есть линия, которую Вы можете изменять при помощи мыши, указывая положения точек. Таким образом анимацию можно задавать при помощи кривой;</li>
        <li>Трек аудиодорожки - можно повесить на определённый момент анимации воспроизведение некоторого звука;</li>
        <li>Трек воспроизведения анимации - это может быть странно, но в воспроизведение анимации можно внедрить воспроизведение другой анимации.</li>
    </ol>
    <p>Добавьте трек кривой безье, и в качестве объекта укажите спрайт карты компьютера. Так как карта должна перевернуться и сменить рубашку на изображение - мы укажем в качестве анимируемого параметра scale. Добавятся два параметра - scale:x и scale:y. Мы будем переворачивать карту по x, поэтому добавьте три ключа для этого параметра, и щёлкните в правой части аниматора на свойство кривой для этого параметра.</p>
    <div class="imagediv"><img src="imgs/scaleproperty.png"></div>
    <div class="imagediv"><img src="imgs/key_insert.png"></div>
    <p>Я сделал таким образом, чтобы параметр scale:x со временем уходил в 0, и возвращался на обратное значение. После завершения редактирования кривой можно вернуться в просмотр анимаций нажав на крестик справа.</p>
    <div class="imagediv"><img src="imgs/Besier.png"></div>
    <p>На момент, когда scale:x равен нулю, наша карта фактически невидима - проверьте это запустив анимацию клавишами, находящимися слева сверху в аниматоре. В момент когда карта невидима необходимо изменить её изображение с рубашки на выбранную компьютером карту. В функции card_changed() мы указывали для переменной карты изображение, которое будет использоваться для карты компьютера. Это мы используем в анимации. В скрипте создайте функцию, которая будет сменять изображение спрайта:</p>
    <pre><code class="code"><hr># Замена текстуры карты компьютера  (событие активируется компонентом "AnimationPlayer")
    func pc_card_swap():
        $Back.texture = pc_card_image<hr></code></pre>
    <p>И теперь в аниматоре добавляем трек вызова метода, и в качестве целевого объекта укажем тот узел, в котором нам необходимо запускать функцию скрипта (мы описывали скрипт для Node2D). Теперь, в таком треке, при создании ключа Godot предложить использовать некоторую функцию. Там мы и указываем нашу функцию pc_card_swap(), которую создали ранее. Если Вы создали ключ не совсем там где нужно, то вы можете спокойно его перетащить левой кнопкой мыши в нужное место.</p>
    <p>После окончания анимации необходимо показать результат игры - давайте опишем такую функцию</p>
    <pre><code class="code"><hr># Отображение результата в завершение игры.  (событие активируется компонентом "AnimationPlayer")
func _result_view():
    if game_result == 1:
        $INFO.text = "~YOU WON~"
        $INFO.visible = true
    elif game_result == -1:
        $INFO.text = "~YOU LOST~"
        $INFO.visible = true
    else:
        $INFO.text = "~DRAW~"
        $INFO.visible = true
    $Timer.start()<hr></code></pre>
    <p>Точно также в трек вызова параметра добавьте новый ключ, и укажите функцию показа результата, и подвиньте этот ключ в конец анимации.</p>
    <p>Так всё же, что за таймер? Пока закомментируйте таймер в коде, и запустите проект. В глаза бросятся две веши: после показа результата ничего не происходит, и очки компьютера и пользователя не отображаются. Если мы исправим первую ситуацию добавив перезагрузку текущей сцены, то появится следующая проблема - мы не увидим результата игры, так как сцена перезагрузится ещё до его отображения. Именно для этого и нужен таймер - сигнал от таймера _on_Timer_Timeout() присоединяем к скрипту, и описываем смену сцены в обработчике этого сигнала.</p>
    <pre><code class="code"><hr># Перезагрузка сцены по событию окончания таймера (событие активируется сигналом компонента "Timer")
func _on_Timer_timeout():
    get_tree().change_scene("res://Main.tscn")<hr></code></pre>
    <p>Запуск таймера теперь можно раскомментировать, и теперь будет видно результат игры. Но ещё есть проблема - очки не отображаются, а поэтому я вынужден дать Вам <b>задание:</b>
        <i>Обратитесь к первой части курса ("Программирование"), и повторите материал темы "Синглтон, глобальные объекты, взаимодействия между сценами". Основываясь на материале приведённой темы из первой части курса реализуйте подсчёт очков, и демонстрацию результатов матчей.</i>
    <a href="projects/KNB.zip" class="project_button">
        <button class="project_button">
            <img src="../../imgs/download.png" style="max-height: 100%">
            Демонстрационный проект
        </button>
    </a>
<br><br>
</div>
<script src="../../scripts/codehighlighter.js"></script>