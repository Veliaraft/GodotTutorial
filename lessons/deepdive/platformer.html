<link rel="stylesheet" href="../../css/contentstyle.css">
<div style="width: 95%; 
            color: #fff; 
            font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            text-align: justify;
            padding-top: 25px;
            padding-left: 2.5%">

    <h1>Платформер</h1>
    <p>Идея следующего туториала заключается не в том, чтобы создать какую-то идеальную игру. По факту множество игр жанра "платформер" похожи друг на друга. У них может отличаться управление, может по разному чувствоваться физика, и т.д.. Но жанр диктует свои правила. Сам жанр, как мы понимаем, исходит от слова "платформа". То есть, кор-механика такого жанра, естественно, перемещение по платформам. Нам такие платформы необходимо создать. Для этого мы можем воспользоваться чем угодно, но предпочтительны три варианта:</p>
    <ol>
        <li>Создавать карту из объектов типа StaticBody, и расставлять вручную весь дизайн локации вместе с указанием твёрдых поверхностей;</li>
        <li>Использовать тайловые карты;</li>
        <li>Использовать прекрасное дополнение - SmartShape2D (документация доступна <a href="https://github.com/SirRamEsq/SmartShape2D" target="_blank">ЗДЕСЬ</a>, сам плагин доступен как по ссылке, так и в магазине ассетов Godot).</li>
    </ol>
    <p>Воспользуемся SmartShape2D, ибо это для нас будет одним из наиболее быстрых рабочих вариантов создания основной части дизайна уровня.</p>
    <p>Для начала перейдите в AssetLib, найдите SmartShape2D в магазине, установите его в проект, и, перейдите в плагины и добавьте его в проект. </p>
    <div class="imagediv"><img src="imgs/howtoloadplugin.png"></div>
    <div class="imagediv"><img src="imgs/howtoinstallplugin.png"></div>
    <p>Вкладка "плагины" всегда доступна в окне настроек проекта. В зависимости от типа плагина теперь он появится в нужном месте. SmartShape2D, например, теперь появится в меню добавления узла.</p>
    <div class="imagediv"><img src="imgs/ss_node.png"></div>
    <p>Я не буду описывать создание игрового поля при помощи данного плагина потому, что за меня это сделали создатели плагина (повторюсь: документация, в которой описано всё от установки до настройки и графики описана <a href="https://github.com/SirRamEsq/SmartShape2D" target="_blank">!!!ЗДЕСЬ!!!</a>). Небольшое примечание - если Вас пугает документация на английском, то Вы можете воспользоваться переводчиком в браузере. На сегодняшний день практически каждый браузер обладает встроенным переводчиком, и если не предлагает перевести страницу - эту функцию всегда можно найти кликнув в свободном месте веб страницы правой кнопкой мыши.</p>
    <p>По примеру использования от разработчиков я создал вот такое игровое поле.</p>

    <div class="imagediv"><img src="imgs/gamespace.png"></div>

    <p>Я сделал многое небрежно - я не гонюсь сейчас за качеством. Мне хочется просто продемонстрировать работу инструмента. Ресурсы для проекта доступны в папке демонстрационного проекта. Не забудьте что Вы создаёте всего лишь текстурированное поле, которое не имеет коллизий. Для того чтобы добавить коллизии и статическое тело для описанной фигуры, достаточно кликнуть на кнопку создания твёрдого тела.
        <div class="imagediv"><img src="imgs/staticbodyfromshape.png"></div>
    Для того, чтобы сделать голубое небо как на картинке, необходимо зайти в настройки проекта, и в графе "Рендеринг" найти параметр "окружение". Измените значение "Чистый цвет по умолчанию" на угодное Вам.</p>
    <p>Теперь, как мы делали это с птичкой - сделайте AnimatedSprite персонажа, и, как мы это делали в конце базового курса программирования - сделайте небольшую физику персонажа, чтобы он мог ходить и прыгать.</p>
    <p>Мы немного разбавим персонажа, и дадим ему в руки оружие. Динозавр будет поворачиваться в сторону курсора, и направлять оружие. Для этого просто добавим динозавру небольшую слежку за курсором в _physics_process():</p>
    <pre><code class="code"><hr>    if get_global_mouse_position().x < position.x:
        $AnimatedSprite.scale.x = -2
    else:
        $AnimatedSprite.scale.x = 2<hr></code></pre>
    <p>В качестве оружия просто добавим динозавру спрайт оружия, но сместим его от центра таким образом, чтобы оно находилось немного сбоку, при этом центр спрайта выставим в центре динозавра</p>
    <div class="imagediv"><img src="imgs/dinowithgun.png"></div>
    <pre><code class="code"><hr>func _physics_process(delta):
    look_at(get_global_mouse_position())
    if fmod(abs(rotation_degrees), 360) > 90 and fmod(abs(rotation_degrees), 360) < 270:
        scale.y = -2
    else:
        scale.y = 2<hr></code></pre>
    <img src="imgs/RT2D.png" align="right">
    <p>Как можно заметить - я также добавил камеру для динозавра. В свойствах камеры я поставил галочку "Current", а позиция камеры будет меняться от динозавра при помощи узла RemoteTransform2D. Мы им пользовались ранее, только не забудьте убрать в свойствах этого узла передачу таких параметров, как поворот и масштаб. Он должен передавать только позицию. Но для чего же такое решение? Всё очень просто. Попробуйте просто однажды высвободить динозаврика отдав ему команду queue_free(), и Вы увидите как камера резко сменит свою позицию - вместе с персонажем будет удалена и камера, которая вложена в него. Это будет означать что основная камера пропадёт, и чтобы что-либо смочь нарисовать - движок переключится на отрисовку вьюпорта. При нашем же решении камера существует отдельно, и при удалении персонажа камера не будет затронута, а просто останется в тех координатах, в которых находилась последнее время.</p>
    <p>Теперь, когда наш динозавр двигается, и способен поворачивать оружие в сторону - очень хочется кликнуть. Для этого создадим пулю - создаём новую сцену "Другой узел", из типов узлов выберем RigidBody2D (так как снаряд должен подчиняться физике движка - мы ленивые разработчики, которым лень писать физику для таких объектов вручную), и добавим туда спрайт projectile, наделив его коллизией и некоторыми свойствами столкновения, а именно нанесение урона, и таймером по окончанию которого снаряд пропадёт, чтобы снаряды не заполоняли экран собой. Не забудьте для RigidBody2D включить contact monitor в инспекторе.</p>
    <pre><code class="code"><hr>extends RigidBody2D

func _on_Timer_timeout():
    queue_free()
    
func _on_RigidBody2D_body_entered(body):
	if body is StaticBody2D:
		pass
	else:
		body.damage(20)
	queue_free()<hr></code></pre>
    <div class="imagediv"><img src="imgs/projectileScene.png"></div>
    <img src="imgs/ML" align="right">
    <p>Да, вот такой огромный скрипт! Но обратите внимание - пуля пытается у противника вызвать метод "damage(число)",  что может вызвать проблемы при столкновении её с землёй. Для этого необходимо сделать так, чтобы она не сталкивалась с землёй, но сталкивалась со слоями где будет находиться персонаж и враги. Для этого необходимо в инспекторе свойств RigidBody2D указать в качестве слоя первый активным - он будет находиться в одном слое с землёй, но указать в качестве маски те слои, где будут находиться игровые персонажи. То есть теперь пуля не сталкивается с землёй - с первым слоем, и желает игнорировать её и лететь дальше, но земля реагирует на пулю выталкивая её. Также необходимо переместить персонажа на один из слоёв, с которыми сталкивается пуля, отключив ему первый слой, а земле в качестве маски столкновений задать маску на всё окружение. Вернёмся к нашей пушке. Она должна этим патроном теперь стрелять. Для этого я дочерним пушке создал Node2D, который мог бы указывать координату появления пули, и дополнил скрипт пушки таким образом, чтобы он создавал пулю из сцены, задавал ей поворот, а также начальную скорость, и помещал её рядом с узлом персонажа в сцене, отдельно от персонажа. Теперь скрипт выглядит так:</p>
    <pre><code class="code"><hr>extends Sprite

var projectile = preload("res://projectile.tscn")
var shooted = false

func _physics_process(delta):
    look_at(get_global_mouse_position())
    if fmod(abs(rotation_degrees), 360) > 90 and fmod(abs(rotation_degrees), 360) < 270:
        scale.y = -2
    else:
        scale.y = 2
    
    if Input.is_mouse_button_pressed(BUTTON_LEFT):
        if !shooted:
            shooted = true
            var bullet = projectile.instance()
            bullet.position = position + $"..".position + Vector2(50*cos(rotation), 50*sin(rotation))
            bullet.rotation_degrees = rotation_degrees
            bullet.apply_impulse(Vector2(0, 0), Vector2(1000*cos(rotation), 1000*sin(rotation)))
            $"../..".add_child(bullet)
    else:
        shooted = false
<hr></code></pre>
    <p>Да, он выглядит достаточно грубо. Но теперь, при прочтении такого кода, должно зародиться некоторое понимание, что математика в школе, всё-же, вещь не такая уж и бесполезная, и, оказывается, может в жизни пригодиться.</p>
    <p>Так как пуля пытается вызвать метод "damage()" - мы опишем такой у нашего динозавра на случай, если пожелаем включить ему столкновение с пулей, и реализовать оружие у противников. Раз есть получаемый урон - значит и есть некоторый показатель отвечающий за количество жизней. Опишем переменную health в начале скрипта, и обработаем её в damage(), но, для игрока важно сделать некоторую поблажку - игроку необходимо дать время на обдумывание ошибки и ухода от опасной ситуации:</p>
    <pre><code class="code"><hr>
# -- Описываем в начале скрипта --
var health = 100
var invincibility = 0

# -- Дополняем _physics_process() --
    ...
    if invincibility > 0:
        invincibility -= 1

# -- Описываем получение урона --
func damage(damage):
	if invincibility == 0:
		health -= damage
		invincibility = 180
		if health <= 0:
			queue_free()<hr></code></pre>
    <p>Также, создадим врагов. Но для начала запечатаем нашего динозаврика в сцену, чтобы его можно было использовать в других сценах. Для этого кликаем правой кнопкой мыши на KinematicBody2D в дереве текущей сцены, и выбираем "сохранить ветку как сцену". Дайте сцене наименование "Player" чтобы точно знать, что эта сцена является нашим главным героем, которого мы сможем использовать многократно, чтобы не создавать каждый раз игрока при создании нового уровня. С врагом мы поступим точно также, только ему предложим физику самостоятельного перемещения без участия устройств ввода, а также дадим ему анимацию красного дракончика, и в слоях коллизий выставим ему необходимый слой, который будет отвечать за врагов, и непосредственно сталкиваться с персонажем. Для удобстав Вы можете задать имена слоям в настройках проекта, вкладка "Основное", раздел "Имена слоя", пункт "2D Физика". Далее я назвал слои подобным образом, и Вы можете видеть как эти слои помечаются при подробном выборе их в инспекторе.</p>
    <div class="imagediv"><img src="imgs/Layers.png"></div>
    <p>Код для врагов, которые просто ходят "туда-сюда", наносят урон игроку при столкновении, и реагируют на пули:</p>
    <pre><code class="code"><hr>extends KinematicBody2D

var velocity = Vector2(6000, 0)
var gravity = 0
var health = 100

func _physics_process(delta):
    for index in get_slide_count():
        var collision = get_slide_collision(index)
        var body = collision.collider
        if body is KinematicBody2D:
            body.damage(50)
    var col = move_and_slide(velocity*delta, Vector2.UP)
    if !is_on_floor():
        gravity += 2500
    else:
        gravity = 0
    if is_on_wall(): # если соприкоснулся со стеной, то меняет направление
        velocity.x *= -1
    velocity.y = gravity

func damage(damage):
    health -= damage
    if health <= 0:
        queue_free()<hr></code></pre>
    <p>Теперь Вы можете также запечатать врага в сцену, и наставить таких динозавриков сколько угодно - они будут ходить от стенки к стенке, и мешать проходить уровень. Но данный код очень грубый - такое создание игры равно тому, что колбасу нарезать ложкой. Я описываю его лишь для простоты понимания, и необходимости разгрузить материал, однако не рекомендую так делать. Для адекватной классификации объектов и возможности безболезненного масштабирования игры пользуйтесь class_name - это позволит Вам использовать какие-либо предопределённые зависимости в качестве унаследованных узлов из любого места игры. Подробнее в документации <a href="https://godot-ru.readthedocs.io/ru/latest/tutorials/scripting/gdscript/gdscript_basics.html?highlight=%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B#classes" target="_blank">ЗДЕСЬ</a>. </p><i>Если возникает вопрос для чего такое необходимо использовать и зачем эти сложности, то отвечу сразу: у нас множество раз дублируется функция damage(). Мы описали её сначала для игрока, а потом для врага. При использовании class_name мы могли описать это один раз, и использовать в дальнейшем для многих объектов просто расширяя скрипт.</i>
    <p>Теперь не хватает всего лишь одной маленькой детали - звуки. Мы не будем искать звуки где попало, скачивать их, и т.д. Воспользуемся плагином gdfxr установив его, как мы делали это ранее со SmartShape2D. Данный плагин поволяет генерировать звуки в режиме реального времени, и сохранять их для проекта.</p>
    <p>Устанавливаем, включаем, и видим как внизу, где ранее мы пользовались аниматором и консолью, появился ещё один пункт - gdfxr. Кликните на него, и вы увидите следующее окно</p>
    <div class="imagediv"><img src="imgs/gdfxr.png"></div>
    <p>в котором я пометил</p>
    <ul>
        <li><b>Зелёным</b> - кнопку создания нового аудиофайла;</li>
        <li><b>Красным</b> - кнопку сохранения аудиофайла;</li>
        <li><b>Фиолетовым</b> - кнопку повторной прослушки сгенерированного звука;</li>
        <li><b>Розовым</b> - варианты предподготовленных настроек для разных типов звуков;</li>
        <li><b>Голубым</b> - настройка генерации звука.</li>
    </ul>
    <p>Просто поиграйте с ним, и пеосмотрите как он работает. В нём нет ничего сложного. Только каждый раз когда Вы сгенерировали звук который Вам нравится - не забудьте его сохранить!</p>
    <b>Задание:</b>
    <i>
        <ul>
            <li>Ранее мы работали со звуками достаточно хорошо создавая музыкальный плеер. Реализуйте при помощи данного плагина простое звуковое сопровождение для игры (AudioStreamPlayer можно использовать многократно, и для разных узлов и звуков)</li>
            <li>Используя StaticBody2D и ColorRect сделайте ещё  несколько платформ, которые представляли бы собой маршрут от начала до конца уровня;</li>
            <li>Реализуйте при помощи Area2D некоторый триггер - логическое завершение в конце маршрута. Когда игрок дойдёт до неё, сцена должна переключиться (пример переключения есть в "Камень, ножницы, бумага"). Сделайте так, чтобы игру можно было пройти;</li>
            <li>Используя анимации реализуйте передвигающуюся платформу из StaticBody2D.</li>
        </ul>
    </i>
    <a href="projects/Platformer.zip" class="project_button">
        <button class="project_button">
            <img src="../../imgs/download.png" style="max-height: 100%">
            Демонстрационный проект
        </button>
    </a>
</div>
<script src="../../scripts/codehighlighter.js"></script>