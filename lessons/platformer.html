<link rel="stylesheet" href="../../css/contentstyle.css">
<div style="width: 95%; 
            color: #fff; 
            font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            text-align: justify;
            padding-top: 25px;
            padding-left: 2.5%">

    <h1>Платформер</h1>
    <p>Идея следующего туториала заключается не в том, чтобы создать какую-то идеальную игру. По факту мнжество игр жанра "платформер" похожи друг на друга. У них может отличаться управление, может по разному чувствоваться физика, и т.д.. Но жанр диктует свои правила. Сам жанр, как мы понимаем, исходит от слова "платформа". То есть, кор-механика такого жанра, естественно, перемещение по платформам. Нам такие платформы необходимо создать. Для этого мы можем  воспользоваться чем угодно. Я же предпочитаю три варианта:</p>
    <ol>
        <li>Создавать карту из объектов типа StaticBody, и расставлять вручную весь дизайн локации вместе с указанием твёрдых поверхностей;</li>
        <li>Использовать тайловые карты;</li>
        <li>Использовать прекрасное дополнение - SmartShape2D (документация доступна <a href="https://github.com/SirRamEsq/SmartShape2D" target="_blank">ЗДЕСЬ</a>, сам плагин доступен как по ссылке, так и в магазине ассетов Godot).</li>
    </ol>
    <p>Воспользуемся SmartShape2D, ибо это для нас будет одним из наиболее быстрых рабочих вариантов создания основной части дизайна уровня.</p>
    <p>Для начала перейдите в AssetLib, найдите SmartShape2D в магазине, установите его в проект, и, перейдите в плагины и добавьте его в проект. </p>
    <div class="imagediv"><img src="imgs/howtoloadplugin.png"></div>
    <div class="imagediv"><img src="imgs/howtoinstallplugin.png"></div>
    <p>Вкладка "плагины" всегда доступна в окне настроек проекта. В зависимости от типа плагина теперь он появится в нужном месте. SmartShape2D, например, теперь появится в меню добавления узла.</p>
    <div class="imagediv"><img src="imgs/ss_node.png"></div>
    <p>Я не буду описывать создание игрового поля при помощи данного плагина потому, что за меня это сделали создатели плагина (повторюсь: документация, в которой описано всё от установки до настройки и графики описана <a href="https://github.com/SirRamEsq/SmartShape2D" target="_blank">!!!ЗДЕСЬ!!!</a>)</p>
    <p>По примеру использования от разработчиков я создал вот такое игровое поле.</p>

    <div class="imagediv"><img src="imgs/gamespace.png"></div>

    <p>Я сделал многое небрежно - я не гонюсь сейчас за качеством. Мне хочется просто продемонстрировать работу инструмента. Ресурсы для проекта доступны в папке демонстрационного проекта.
    Для того, чтобы сделать голубое небо как на картинке, необходимо зайти в настройки проекта, и в графе "Рендеринг" найти параметр "окружение". Измените значение "Чистый цвет по умолчанию" на угодное Вам.</p>
    <p>Теперь, как мы делали это с птичкой - сделайте AnimatedSprite персонажа, и, как мы это делали в конце базового курса программирования - сделайте небольшую физику персонажа, чтобы он мог ходить и прыгать.</p>
    <p>Мы немного разбавим персонажа, и дадим ему в руки оружие. Динозавр будет поворачиваться в сторону курсора, и направлять оружие. Для этого просто добавим динозавру небольшую слежку за курсором в _physics_process():</p>
    <pre><code class="code"><hr>    if get_global_mouse_position().x < position.x:
        $AnimatedSprite.scale.x = -2
    else:
        $AnimatedSprite.scale.x = 2<hr></code></pre>
    <p>В качестве оружия просто добавим динозавру спрайт оружия, но сместим его от центра таким образом, чтобы оно находилось немного сбоку, при этом центр спрайта выставим в центре динозавра</p>
    <div class="imagediv"><img src="imgs/dinowithgun.png"></div>
    <pre><code class="code"><hr>func _physics_process(delta):
    look_at(get_global_mouse_position())
    if fmod(abs(rotation_degrees), 360) > 90 and fmod(abs(rotation_degrees), 360) < 270:
        scale.y = -2
    else:
        scale.y = 2<hr></code></pre>
    <img src="imgs/RT2D.png" align="right">
    <p>Как можно заметить - я также добавил камеру для динозавра. В свойствах камеры я поставил галочку "Current", а позиция камеры будет меняться от динозавра при помощи узла RemoteTransform2D. Мы им пользовались ранее, только не забудьте убрать в свойствах этого узла передачу таких параметров, как поворот и масштаб. Он должен передавать только позицию. Но для чего же такое решение? Всё очень просто. Попробуйте просто однажды высвободить динозаврика отдав ему команду queue_free(), и Вы увидите как камера резко сменит свою позицию - вместе с персонажем будет удалена и камера, которая вложена в него. Это будет означать что основная камера пропадёт, и чтобы что-либо смочь нарисовать - движок переключится на отрисовку вьюпорта. При нашем же решении камера существует отдельно, и при удалении персонажа камера не будет затронута, а просто останется в тех координатах, в которых находилась последнее время.</p>
    <p>Теперь, когда наш динозавр двигается, и способен поворачивать оружие в сторону - очень хочется кликнуть. Для этого создадим пулю - создаём новую сцену "Другой узел", из типов узлов выберем RigidBody2D (так как снаряд должен подчиняться физике движка - мы ленивые разработчики, которым лень писать физику для таких объектов вручную), и добавим туда спрайт projectile, наделив его коллизией и некоторыми свойствами столкновения, а именно нанесение урона, и таймером по окончанию которого снаряд пропадёт, чтобы снаряды не заполоняли экран собой. Не забудьте для RigidBody2D включить contact monitor в инспекторе.</p>
    <pre><code class="code"><hr>extends RigidBody2D

func _on_Timer_timeout():
    queue_free()
    
func _on_RigidBody2D_body_entered(body):
    if body != StaticBody2D:
        body.damage(20)
    queue_free()<hr></code></pre>
    <div class="imagediv"><img src="imgs/projectileScene.png"></div>
    <img src="imgs/ML" align="right">
    <p>Да, вот такой огромный скрипт! Но обратите внимание - пуля пытается у противника вызвать метод "damage(число)",  что может вызвать проблемы при столкновении её с землёй. Для этого необходимо сделать так, чтобы она не сталкивалась с землёй, но сталкивалась со слоями где будет находиться персонаж и враги. Для этого необходимо в инспекторе свойств RigidBody2D указать в качестве слоя первый активным - он будет находиться в одном слое с землёй, но указать в качестве маски те слои, где будут находиться игровые персонажи. То есть теперь пуля не сталкивается с землёй - с первым слоем, и желает игнорировать её и лететь дальше, но земля реагирует на пулю выталкивая её. Также необходимо переместить персонажа на один из слоёв, с которыми сталкивается пуля, отключив ему первый слой, а земле в качестве маски столкновений задать маску на всё окружение. Вернёмся к нашей пушке. Она должна этим патроном теперь стрелять. Для этого я дочерним пушке создал Node2D, который мог бы указывать координату появления пули, и дополнил скрипт пушки таким образом, чтобы он создавал пулю из сцены, задавал ей поворот, а также начальную скорость, и помещал её рядом с узлом персонажа в сцене, отдельно от персонажа. Теперь скрипт выглядит так:</p>
    <pre><code class="code"><hr>extends Sprite

var projectile = preload("res://projectile.tscn")
var shooted = false

func _physics_process(delta):
    look_at(get_global_mouse_position())
    if fmod(abs(rotation_degrees), 360) > 90 and fmod(abs(rotation_degrees), 360) < 270:
        scale.y = -2
    else:
        scale.y = 2
    
    if Input.is_mouse_button_pressed(BUTTON_LEFT):
        if !shooted:
            shooted = true
            var bullet = projectile.instance()
            bullet.position = position + $"..".position + Vector2(50*cos(rotation), 50*sin(rotation))
            bullet.rotation_degrees = rotation_degrees
            bullet.apply_impulse(Vector2(0, 0), Vector2(1000*cos(rotation), 1000*sin(rotation)))
            $"../..".add_child(bullet)
    else:
        shooted = false
<hr></code></pre>
    <p>Да, он выглядит достаточно грубо. Но теперь, при прочтении такого кода, должно зародиться некоторое понимание, что математика в школе, всё-же, вещь не такая уж и бесполезная, и, оказывается, может в жизни пригодиться.</p>
    <p>Так как пуля пытается вызвать метод "damage()" - мы опишем такой у нашего динозавра на случай, если пожелаем включить ему столкновение с пулей, и реализовать оружие у противников. Раз есть получаемый урон - значит и есть некоторый показатель отвечающий за количество жизней. Опишем переменную health в начале скрипта, и обработаем её в damage():</p>
    <pre><code class="code"><hr>var health = 100
func damage(damage):
    health -= damage
    if health <= 0:
        queue_free()<hr></code></pre>
    <p>Также, создадим врагов.</p>
    <p></p>
    <ol>
        <li></li>
    </ol>
    <img src="" align="right">
    <div class="imagediv"><img src=""></div>
    <pre><code class="code"><hr><hr></code></pre>
    <a href="projects/01 Calc.zip" class="project_button">
        <button class="project_button">
            <img src="../../imgs/download.png" style="max-height: 100%">
            Демонстрационный проект
        </button>
    </a>
<br><br>
</div>
<script src="../../scripts/codehighlighter.js"></script>